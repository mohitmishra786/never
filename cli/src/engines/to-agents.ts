/**
 * AGENTS.md format converter
 * Generates a universal AGENTS.md file compatible with the Agentic AI Foundation spec
 */

import { existsSync, readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import type { ParsedRule } from './parser.js';

const NEVER_SECTION_START = '<!-- NEVER-RULES-START -->';
const NEVER_SECTION_END = '<!-- NEVER-RULES-END -->';

/**
 * Result of a sync operation for testability
 */
export interface EngineSyncResult {
    path: string;
    content: string;
    written: boolean;
}

/**
 * Generate AGENTS.md content from rules
 */
export function generateAgentsContent(rules: ParsedRule[]): string {
    const sections: string[] = [];

    // Group rules by their category
    const groupedRules = new Map<string, ParsedRule[]>();

    for (const rule of rules) {
        const groupName = rule.frontmatter.name;
        if (!groupedRules.has(groupName)) {
            groupedRules.set(groupName, []);
        }
        groupedRules.get(groupName)!.push(rule);
    }

    // Generate content for each group
    for (const [groupName, groupRules] of groupedRules) {
        sections.push(`### ${groupName}\n`);
        sections.push(`> ${groupRules[0]?.frontmatter.description || 'No description'}\n`);

        for (const rule of groupRules) {
            for (const neverRule of rule.rules) {
                sections.push(`- ${neverRule}`);
            }
        }

        sections.push(''); // Add blank line between sections
    }

    return sections.join('\n');
}

/**
 * Generate the full AGENTS.md file content
 */
export function generateAgentsFile(rules: ParsedRule[]): string {
    const rulesContent = generateAgentsContent(rules);
    const timestamp = new Date().toISOString().split('T')[0];

    return `# AGENTS.md

This file provides guidance and constraints for AI coding agents working on this project.
It follows the [Agentic AI Foundation](https://aaif.io) specification.

## Overview

This project uses the [Never](https://github.com/mohitmishra786/never) constraint system to define
rules that AI agents should follow. These rules help maintain code quality, security, and consistency.

## Last Updated

${timestamp}

${NEVER_SECTION_START}

## Constraints

The following "Never" rules apply to all AI agents working on this codebase:

${rulesContent}
${NEVER_SECTION_END}

## Additional Guidelines

For project-specific guidelines not covered by the Never rules above, add them below.

---

*This file is partially auto-generated by Never CLI. Manual edits outside the marked sections will be preserved.*
`;
}

/**
 * Replace the text between two marker strings in an existing document with the provided rules block.
 *
 * Searches for `startMarker` and the first `endMarker` occurring after it; if both markers are found and ordered
 * correctly, returns a new string where the content between them is replaced by a standardized constraints block
 * that includes `rulesContent`. If the markers are missing or misordered, returns `null`.
 *
 * @param existingContent - The original document content to search within
 * @param rulesContent - The rules text to insert between the markers
 * @param startMarker - The exact starting marker string that precedes the section to replace
 * @param endMarker - The exact ending marker string that follows the section to replace
 * @returns The updated document content with the markers' section replaced, or `null` if replacement cannot be performed
 */
function replaceMarkerSection(
    existingContent: string,
    rulesContent: string,
    startMarker: string,
    endMarker: string
): string | null {
    const startIndex = existingContent.indexOf(startMarker);
    // Find end marker AFTER the start marker to avoid false matches
    const endIndex = existingContent.indexOf(
        endMarker,
        startIndex + startMarker.length
    );

    // Validate marker positions
    if (startIndex < 0 || endIndex < 0 || endIndex <= startIndex) {
        return null;
    }

    const beforeMarker = existingContent.slice(0, startIndex);
    const afterMarker = existingContent.slice(endIndex + endMarker.length);

    return `${beforeMarker}${startMarker}

## Constraints

The following "Never" rules apply to all AI agents working on this codebase:

${rulesContent}
${endMarker}${afterMarker}`;
}

/**
 * Create or update the AGENTS.md file for a project with the generated Never-rule sections.
 *
 * Replaces the content between NEVER_SECTION_START and NEVER_SECTION_END if those markers exist;
 * otherwise appends a Never constraints block to the existing file or generates a new AGENTS.md.
 *
 * @param projectPath - Path to the project directory where AGENTS.md should be created or updated
 * @param rules - Parsed Never-rule definitions used to generate the constraints section
 * @param dryRun - If `true`, do not write changes to disk; still returns the resulting content
 * @returns An EngineSyncResult with `path` set to the AGENTS.md path, `content` containing the final file text, and `written` set to `true` if the file was written to disk, `false` for a dry run
 */
export function updateAgentsFile(
    projectPath: string,
    rules: ParsedRule[],
    dryRun: boolean = false
): EngineSyncResult {
    const agentsPath = join(projectPath, 'AGENTS.md');
    const rulesContent = generateAgentsContent(rules);
    let finalContent: string;

    if (existsSync(agentsPath)) {
        // Read existing file
        const existingContent = readFileSync(agentsPath, 'utf-8');

        // Try to replace the section between markers
        const replaced = replaceMarkerSection(
            existingContent,
            rulesContent,
            NEVER_SECTION_START,
            NEVER_SECTION_END
        );

        if (replaced !== null) {
            finalContent = replaced;
        } else {
            // Append our section to the end
            finalContent = `${existingContent.trim()}

---

${NEVER_SECTION_START}

## Never Constraints

${rulesContent}
${NEVER_SECTION_END}
`;
        }
    } else {
        // Create new file
        finalContent = generateAgentsFile(rules);
    }

    if (!dryRun) {
        writeFileSync(agentsPath, finalContent, 'utf-8');
    }

    return {
        path: agentsPath,
        content: finalContent,
        written: !dryRun,
    };
}